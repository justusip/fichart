import React, {useEffect, useState} from "react";
import Interval from "../misc/Interval";
import EventListener from "react-event-listener";
import moment from "moment";
import Indicator from "../indicators/Indicator";

export default function Chart(props: {
    className: string,
    data: Interval[] ,
    indicators: Indicator[]
}) {
    const canvas = React.createRef<HTMLCanvasElement>();

    const [width, setWidth] = useState(0);
    const [height, setHeight] = useState(0);
    const onResize = () => {
        setWidth(canvas.current.clientWidth * window.devicePixelRatio);
        setHeight(canvas.current.clientHeight * window.devicePixelRatio);
    };
    useEffect(() => {
        canvas.current.width = width;
        canvas.current.height = height;
    }, [width, height]);
    useEffect(() => {
        onResize();
    }, []);

    let dragging = false;
    let showCursor = false;
    let mouseX = 0;
    let mouseY = 0;

    let maxTimeRange = 30 * 24 * 60 * 60; //1 month
    let minTimeRange = 60 * 60;

    let boundLeft = 1611883800;
    let boundRight = boundLeft + 4 * 60 * 60;
    let boundBottom = 10;
    let boundTop = 20;

    let boundTimeRange = boundRight - boundLeft;
    let boundPriceRange = boundTop - boundBottom;

    let boundVolTop = 100000000;

    function recalculateBounds() {
        boundTimeRange = boundRight - boundLeft;
        boundPriceRange = boundTop - boundBottom;
    }

    useEffect(() => {
        calcIndicators();
        draw();
    }, [props.data, width, height]);

    const s = {
        background: "#2d2d2d",
        grid: "#404040",
        divisor: "#777",
        cursorHighlight: "#ffffff33",
        bodyRisen: "#51ab82",
        bodyDropped: "#8a3334",
        text: "#777"
        // shadow: "#464e56",
        // overview: "#777" // When the graph is shrunk horizontally to extreme and the candle bodies are not visible
    };

    // +-------------------------------------------------------------------------+
    // |                                    |                                    |
    // |                                    |                                    |
    // |                                    | [mouseY, ctx.fillRect(...)]        |
    // |    [ctx.fillRect(...) / mouseX]    |                                    |
    // |             xToTime(x)             |                                    |
    // |------------------------------------+------------------------------------|
    // |                                    |                                    |
    // |                                    |                                    |
    // |                                    | yToPrice(y)                        |
    // |                                    |                                    |
    // |                                    |                                    |
    // +-------------------------------------------------------------------------+

    const drawText = (
        ctx: CanvasRenderingContext2D,
        msg: string,
        x: number,
        y: number,
        colour: string,
    ) => {
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.fillStyle = colour;
        ctx.font = `${12 * devicePixelRatio}px PlexSans`;
        ctx.fillText(msg, x, height - y);
    };
    const drawTextbox = (
        ctx: CanvasRenderingContext2D,
        msg: string,
        x: number,
        y: number,
        colour: string,
        bg: string
    ) => {
        const padding = 16 * devicePixelRatio;

        // Draws background
        ctx.fillStyle = bg;
        const rectWidth = measureTextWidth(ctx, msg) + padding;
        const rectHeight = measureTextHeight(ctx, msg) + padding;
        ctx.fillRect(x - (rectWidth / 2), height - y - (rectHeight / 2), rectWidth, rectHeight);

        // Draws text
        drawText(ctx, msg, x, y, colour);
    };
    const measureText = (ctx: CanvasRenderingContext2D, msg: string): TextMetrics => {
        ctx.font = `${12 * devicePixelRatio}px PlexSans`;
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        return ctx.measureText(msg);
    };
    const measureTextWidth = (ctx: CanvasRenderingContext2D, msg: string): number => {
        const textMetrics = measureText(ctx, msg);
        return Math.abs(textMetrics.actualBoundingBoxLeft) + Math.abs(textMetrics.actualBoundingBoxRight);
    };
    const measureTextHeight = (ctx: CanvasRenderingContext2D, msg: string): number => {
        const textMetrics = measureText(ctx, msg);
        return Math.abs(textMetrics.actualBoundingBoxAscent) + Math.abs(textMetrics.actualBoundingBoxDescent);
    };

    let volumeHeight = 100;
    let bottomHeight = 0;
    let chartHeight = height - volumeHeight - bottomHeight;
    let rightWidth = 60;
    let chartWidth = width - rightWidth;

    const timeStep = 1 * 60;
    const xToTime = (x: number) => x / chartWidth * boundTimeRange + boundLeft;
    const timeToX = (time: number) => (time - boundLeft) / boundTimeRange * chartWidth;

    const priceStep = 1.0;
    const yToPrice = (y: number) => y / height * boundPriceRange + boundBottom;
    const priceToY = (price: number) => (price - boundBottom) / boundPriceRange * chartHeight + volumeHeight + bottomHeight;

    const timesPerGridline = [10 * 60, 30 * 60, 60 * 60];
    const timePerGridline = 10 * 60;
    const pricePerGridline = 1;

    const findData = (time: number) => props.data.find(interval => interval.sTime === time); //TODO optimize
    const rectPadding = 2;

    const prevStep = (val: number, step: number) => Math.floor(val / step) * step;
    const nextStep = (val: number, step: number) => Math.ceil(val / step) * step;

    const calcIndicators = () => {
        for (const interval of props.data)
            interval.indicators = {};
        for (const indicator of props.indicators)
            indicator.calculate(props.data);
    };

    const draw = () => {
        const ctx = canvas.current.getContext("2d");
        ctx.fillStyle = s.background;
        ctx.fillRect(0, 0, width, height);

        bottomHeight = measureTextHeight(ctx, "1.234567890") + 16 * devicePixelRatio;
        rightWidth = measureTextWidth(ctx, "14.00") + 16 * devicePixelRatio;
        chartHeight = height - volumeHeight - bottomHeight;
        chartWidth = width - rightWidth;

        // Finding boundaries
        //TODO
        boundTop = props.data.map(interval => interval.high).sort((a, b) => b - a)[0];
        boundBottom = props.data.map(interval => interval.low).sort((a, b) => a - b)[0];
        boundVolTop = props.data.map(interval => interval.volume).sort((a, b) => b - a)[0];
        recalculateBounds();

        // Draw Grid
        {
            ctx.fillStyle = s.grid;
            // Horizontal lines (Prices)
            for (
                let price = nextStep(boundBottom, pricePerGridline);
                price < nextStep(boundTop, pricePerGridline);
                price++
            ) {
                const y = priceToY(price);
                ctx.fillRect(0, height - y, chartWidth, 1);
            }
            // Vertical lines (Times)
            for (
                let time = nextStep(boundLeft, timePerGridline);
                time <= prevStep(boundRight, timePerGridline);
                time += timePerGridline
            ) {
                const x = timeToX(time);
                ctx.fillRect(x, 0, 1, chartHeight + volumeHeight);
            }
        }

        const prevIndiVals: { [id: string]: { x: number, y: number } | null } = {};
        // Draw candlesticks and volume bars
        for (
            let time = prevStep(boundLeft, timeStep);
            time <= nextStep(boundRight, timeStep);
            time += timeStep
        ) {
            const interval = findData(time);

            const segLeft = timeToX(time);
            const segRight = timeToX(time + timeStep);
            const segWidth = segRight - segLeft;
            const segCenter = (segLeft + segRight) / 2;

            if (!interval) {
                ctx.fillStyle = "#222";
                ctx.fillRect(segLeft, 0, segRight - segLeft, height - bottomHeight);
                continue;
            }

            const rectLeft = segLeft + rectPadding;
            const rectRight = segRight - rectPadding + 1;
            const rectWidth = rectRight - rectLeft;

            const risen = interval.close > interval.open;
            ctx.fillStyle = risen ? s.bodyRisen : s.bodyDropped;

            // Draw Shadow
            const lineTop = priceToY(interval.high);
            const lineBottom = priceToY(interval.low);
            ctx.fillRect(segCenter, height - lineTop, 1, lineTop - lineBottom);

            // Draw Body
            if (rectWidth > 0) {
                const higherEnd = risen ? interval.open : interval.close;
                const rectTop = priceToY(higherEnd);

                const lowerEnd = !risen ? interval.open : interval.close;
                const rectBottom = priceToY(lowerEnd);

                ctx.fillRect(rectLeft, height - rectTop, rectWidth, rectTop - rectBottom);
            }

            // Draw Volume
            const volTop = interval.volume / boundVolTop * volumeHeight + bottomHeight;
            const volBottom = bottomHeight;
            ctx.fillRect(rectLeft, height - volTop, Math.max(rectWidth, 1), volTop - volBottom);

            //Draw Indicators
            for (const indicator of props.indicators) {
                ctx.lineWidth = indicator.lineWidth;
                ctx.strokeStyle = indicator.colour;
                const price = interval.indicators[indicator.id];
                if (!price)
                    continue;
                const startLoc = prevIndiVals[indicator.id];
                const endX = segCenter;
                const endY = priceToY(price);
                if (!!startLoc) {
                    ctx.beginPath();
                    ctx.moveTo(startLoc.x, height - startLoc.y);
                    ctx.lineTo(endX, height - endY);
                    ctx.stroke();
                    ctx.closePath();
                }
                prevIndiVals[indicator.id] = {x: endX, y: endY};
            }
        }

        // Draw borders and labels
        {
            // Draws background for right outer area to hide that 1 bar out of the inner area
            ctx.fillStyle = s.background;
            ctx.fillRect(chartWidth, 0, width - chartWidth, height);

            //Prices
            for (
                let price = nextStep(boundBottom, pricePerGridline);
                price < nextStep(boundTop, pricePerGridline);
                price++
            ) {
                const y = priceToY(price);
                const val = price.toFixed(2);
                drawText(ctx, val, width - (rightWidth / 2), y, s.text);
            }
            //Times
            for (
                let time = nextStep(boundLeft, timePerGridline);
                time <= prevStep(boundRight, timePerGridline);
                time += timePerGridline
            ) {
                const x = timeToX(time + (timeStep / 2));
                const val = moment(time * 1000).format("HH:mm");
                drawText(ctx, val, x, bottomHeight / 2, s.text);
            }

            ctx.fillStyle = s.divisor;
            ctx.fillRect(0, chartHeight, chartWidth, 1); // Divisor between candlesticks and volume
            ctx.fillRect(0, chartHeight + volumeHeight, width, 1); // Divisor between volume and numbers
            ctx.fillRect(chartWidth, 0, 1, height); // Divisor between chart and numbers
        }

        // Draw Cursor
        if (showCursor && mouseX < chartWidth && mouseY < height - bottomHeight) {
            const price = yToPrice(height - mouseY);
            const time = prevStep(xToTime(mouseX), timeStep);

            const priceLblText = price.toFixed(2);
            const priceLblCenter = (chartWidth + width) / 2;
            drawTextbox(ctx, priceLblText, priceLblCenter, height - mouseY, "#fff", "#777");

            // Cursor vertical Line
            ctx.fillStyle = s.cursorHighlight;
            ctx.fillRect(0, mouseY, chartWidth, 1);

            const rectLeft = timeToX(time);
            const rectRight = timeToX(time + timeStep);
            const rectWidth = rectRight - rectLeft;
            const rectCenter = (rectLeft + rectRight) / 2;

            ctx.fillStyle = s.cursorHighlight;
            ctx.fillRect(rectLeft, 0, rectWidth, height - bottomHeight);

            const timeVal = moment(time * 1000).format("DD/MM/YYYY HH:mm:ss");

            drawTextbox(ctx, timeVal, rectCenter, bottomHeight / 2, "#fff", "#777");
        }
    };

    const onMouseEnter = (e: React.MouseEvent<HTMLCanvasElement>) => {
        showCursor = true;
        draw();
    };

    const onMouseOut = (e: React.MouseEvent<HTMLCanvasElement>) => {
        showCursor = false;
        dragging = false;
        draw();
    };

    const onMouseDown = (e: React.MouseEvent<HTMLCanvasElement>) => {
        canvas.current.style["cursor"] = "grabbing";
        dragging = true;
    };

    const onMouseUp = (e: React.MouseEvent<HTMLCanvasElement>) => {
        canvas.current.style["cursor"] = null;
        dragging = false;
    };

    const onMouseMove = (e: React.MouseEvent<HTMLCanvasElement>) => {
        const elmRect = canvas.current.getBoundingClientRect();
        mouseX = (e.clientX - elmRect.left) * devicePixelRatio;
        mouseY = (e.clientY - elmRect.top) * devicePixelRatio;
        // if (mouseX < 0 || mouseY < 0 || mouseX > elmRect.width || mouseY > elmRect.height)
        //     dragging = false;
        // else
        //     dragging = true

        let shouldRedraw = false;

        if (showCursor) {
            shouldRedraw = true;
        }

        if (dragging) {
            const offsetX = e.movementX;
            const offsetTime = offsetX / canvas.current.clientWidth * boundTimeRange;
            boundLeft -= offsetTime;
            boundRight -= offsetTime;
            recalculateBounds();
            shouldRedraw = true;
        }

        if (shouldRedraw) {
            draw();
        }
    };

    const onWheel = (e: React.WheelEvent) => {
        const delta = e.deltaY;
        const scale = 1.08;
        const multiplier = (delta > 0) ? scale : (1 / scale);
        const pivot = xToTime(e.clientX);

        const newBoundLeft = pivot - ((pivot - boundLeft) * multiplier);
        const newBoundRight = pivot + ((boundRight - pivot) * multiplier);
        const newBoundTimeRange = boundRight - boundLeft;
        if (newBoundTimeRange > maxTimeRange && multiplier > 1) {
            return;
        } else if (newBoundTimeRange < minTimeRange && multiplier < 1) {
            return;
        }

        // if (newBoundTimeRange > maxTimeRange) {
        //     boundLeft = pivot - (maxTimeRange / 2);
        //     boundRight = pivot + (maxTimeRange / 2);
        // } else if (newBoundTimeRange < minTimeRange) {
        //     boundLeft = pivot - (minTimeRange / 2);
        //     boundRight = pivot + (minTimeRange / 2);
        // }

        boundLeft = newBoundLeft;
        boundRight = newBoundRight;
        recalculateBounds();
        draw();
    };

    return <div className={props.className}>
        <canvas ref={canvas}
                className="w-full h-full cursor-crosshair"
                onMouseOver={onMouseEnter}
                onMouseOut={onMouseOut}
                onMouseDown={onMouseDown}
                onMouseUp={onMouseUp}
                onMouseMove={onMouseMove}
                onWheel={onWheel}>
            <EventListener
                target="window"
                onResize={onResize}
            />
        </canvas>
    </div>;
}
